// PDF Export utility using jsPDF (or similar)
// Note: This is a mock implementation. In production, you'd use a proper PDF library

export interface PDFExportOptions {
  title?: string;
  author?: string;
  fontSize?: number;
  marginTop?: number;
  marginLeft?: number;
  pageWidth?: number;
  pageHeight?: number;
}

export class PDFExporter {
  static async generatePDF(script: string, options: PDFExportOptions = {}): Promise<Blob> {
    const {
      title = 'Untitled Script',
      author = 'ScriptStudio User',
      fontSize = 12,
      marginTop = 72,
      marginLeft = 72,
    } = options;

    // This is a mock implementation
    // In production, you'd use jsPDF or similar library
    const pdfContent = this.generatePDFContent(script, {
      title,
      author,
      fontSize,
      marginTop,
      marginLeft
    });

    // Create a mock PDF blob
    const blob = new Blob([pdfContent], { type: 'application/pdf' });
    return blob;
  }

  private static generatePDFContent(script: string, options: PDFExportOptions): string {
    const { title, author } = options;
    
    // Mock PDF content (in production, this would generate actual PDF bytes)
    return `%PDF-1.4
Mock PDF Content for: ${title}
Author: ${author}
Generated by ScriptStudio

Script Content:
${script}

This is a mock PDF implementation. In production, you would use a proper PDF library like jsPDF.`;
  }

  static generateFilename(title?: string): string {
    const safeTitle = title?.replace(/[^a-zA-Z0-9\s-]/g, '').replace(/\s+/g, '_') || 'script';
    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    return `${safeTitle}_${timestamp}.pdf`;
  }

  // Convert script to professional screenplay format for PDF
  static formatForPDF(script: string): string {
    const lines = script.split('\n');
    let formattedScript = '';
    
    for (let line of lines) {
      line = line.trim();
      if (!line) {
        formattedScript += '\n';
        continue;
      }

      // Scene headings (INT./EXT.)
      if (line.match(/^(INT\.|EXT\.)/i)) {
        formattedScript += `\n${line.toUpperCase()}\n\n`;
        continue;
      }

      // Character names (ALL CAPS, typically centered)
      if (line.match(/^[A-Z][A-Z\s]+$/) && line.length < 30 && !line.includes('.')) {
        formattedScript += `                    ${line}\n`;
        continue;
      }

      // Parentheticals
      if (line.match(/^\(.+\)$/)) {
        formattedScript += `                ${line}\n`;
        continue;
      }

      // Transitions (FADE OUT, CUT TO, etc.)
      if (line.match(/^(FADE|CUT|DISSOLVE|SMASH CUT)/i)) {
        formattedScript += `                                        ${line.toUpperCase()}\n\n`;
        continue;
      }

      // Check if it's dialogue (follows character name or parenthetical)
      const prevLines = formattedScript.split('\n').slice(-3);
      const isAfterCharacterName = prevLines.some(prevLine => 
        prevLine.trim().match(/^[A-Z][A-Z\s]+$/) && prevLine.trim().length < 30
      );
      const isAfterParenthetical = prevLines.some(prevLine => 
        prevLine.trim().match(/^\(.+\)$/)
      );

      if (isAfterCharacterName || isAfterParenthetical) {
        // Dialogue - indent from left margin
        formattedScript += `          ${line}\n`;
      } else {
        // Action/Description
        formattedScript += `${line}\n`;
      }
    }

    return formattedScript;
  }
}

// Enhanced export functions for different formats
export const exportScript = async (
  script: string, 
  format: 'pdf' | 'fdx' | 'txt', 
  options: any = {}
): Promise<{ blob: Blob; filename: string }> => {
  
  switch (format) {
    case 'pdf': {
      const formattedScript = PDFExporter.formatForPDF(script);
      const blob = await PDFExporter.generatePDF(formattedScript, options);
      const filename = PDFExporter.generateFilename(options.title);
      return { blob, filename };
    }
    
    case 'fdx': {
      // Use existing FDX exporter
      const { FDXExporter } = await import('./fdxExporter');
      const blob = await FDXExporter.generateDownloadBlob(script, options);
      const filename = FDXExporter.generateFilename(options.title);
      return { blob, filename };
    }
    
    case 'txt': {
      const formattedScript = PDFExporter.formatForPDF(script);
      const blob = new Blob([formattedScript], { type: 'text/plain' });
      const safeTitle = options.title?.replace(/[^a-zA-Z0-9\s-]/g, '').replace(/\s+/g, '_') || 'script';
      const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
      const filename = `${safeTitle}_${timestamp}.txt`;
      return { blob, filename };
    }
    
    default:
      throw new Error(`Unsupported format: ${format}`);
  }
};